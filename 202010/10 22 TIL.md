# Data Structure 
## Stack
스택의 구현 방법은 배열을 사용하는 것과 연결 리스트를 사용하는 것 두 가지가 있습니다. 스택은 밑이 막힌 상자라 하였는데, 이 상자를 배열로 구현할 것인가, 아니면 연결 리스트를 사용하여 구현할 것인가 입니다.

두 방법 모두 장단점이 존재합니다. 배열의 장점은 구현이 쉽고, 원하는 데이터의 접근 속도가 빠릅니다. 만약 내가 원하는 데이터가 배열의 3번째 위치에 있으면 arr[2]를 사용한다면 한번에 접근이 가능하기 때문입니다. 하지만 단점으로는 데이터 최대 개수를 미리 정해야 합니다. 또한 데이터의 삽입과 삭제에 있어 매우 비효율 적입니다. 아래의 그림을 보면, 두번째 위치에 x라는 데이터를 삽입하려고 합니다. 그러면 2,3,4,5,6 데이터들(두번째 위치부터 마지막 데이터까지)은 모두 한칸씩 옮겨 두 번째 칸을 비워놔야 합니다. 칸을 비워놔야 삽입이 가능하기 때문이죠. 만약 100,000,000개의 데이터가 있는데 첫 번째 위치에 데이터를 삽입하려 하면, 그 뒤에 있는 모든 데이터(100,000,000개)를 한칸씩 옮겨야 합니다. 이것은 시간적으로나 비용적으로나 엄청난 손해입니다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10695180-af51-4f0d-8c26-2627f2e537d9/22523739589924BE03.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10695180-af51-4f0d-8c26-2627f2e537d9/22523739589924BE03.png)

연결 리스트의 장점으로는 데이터의 최대 개수가 한정되어 있지 않고, 데이터의 삽입 삭제가 용이합니다. 연결리스트의 구조는 배열과 다르게 데이터들이 순차적으로 나열되어 있지 않습니다. 아래 그림처럼 연결리스트를 구성하고 있는 요소를 노드라고 합니다. 이 노드는 데이터와 다음 위치에 해당하는 노드의 주소값을 갖습니다. 이러한 구조 때문에 연결리스트 중간에 데이터를 삽입하는 방법은 쉽습니다. 다음 위치에 해당하는 노드의 주소값만 바꿔주면 되기 때문이죠. 하지만 치명적인 단점은 배열과 다르게 한번에 원하는 데이터의 접근이 불가능합니다. 연결되어 있는 링크를 따라 차근차근 하나씩 확인하며 데이터를 찾아야 하기 때문이죠.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/55e231cc-43db-4334-b229-81b0f7dc8278/2634FB425899267409.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/55e231cc-43db-4334-b229-81b0f7dc8278/2634FB425899267409.png)

이처럼 배열, 연결리스트 각각의 장단점이 있습니다. 배열은 데이터 양이 많지만 삽입/삭제가 거의 없고, 데이터의 접근이 빈번히 이뤄질 때 유리합니다. 반대로 연결리스트는 삽입/삭제가 빈번히 이뤄지고, 데이터의 접근이 거의 없을 때 유리합니다. 각각의 상황에 맞게 배열을 사용할지, 연결리스트를 사용할지는 개발자의 몫인 것 같습니다.

## 스택 mothod 구현하기

- `push(element)` - 요소를 스택의 최상단에 추가합니다.
- `pop()` - 스택의 최상단에서 요소를 제거하고 반환합니다.
- `size()` - 스택의 현재 요소 개수를 반환합니다.
```jsx
class Stack {
  constructor() {
    this.storage = {};
    this.top = 0;
  }
  size() {
    //스택에 현재 몇개의 접시가 있는지 확인하는 로직
    if(this.top <= 0) {
      return 0;
    } else {
      return this.top;
    }
  }

  push(element) {
    if(this.top <= 0) {
      this.top = 0; //0보다 작을 경우 , 0으로 세팅
      this.storage[this.top] = element;
      this.top ++;
    }
    else {
    this.storage[this.top] = element;
    this.top ++;
    }
  }

  pop() {
    if(this.top < 0) {
      return;
    }
    delete this.storage[this.top];
    this.top--;
    return this.storage[this.top];
  }
}

module.exports = Stack;
```